# 23 约束入门与代码设计指南（新手版）

本文目标：让新手**完全理解“什么是约束”**、**为什么要用约束**，以及**本项目的约束代码是如何设计的**。最后还会讲清楚“如果要新增约束，应该怎么改代码”。

---

## 一、先用大白话解释“约束”是什么

把粒子想成一串珠子，你希望它们**保持某种关系**，比如：
- 相邻两颗珠子的距离固定
- 角度不要太弯
- 不能穿过地面

这些“必须满足的规则”就叫 **约束**。

在 PBD 里，约束不是“慢慢推”，而是每一帧都把它们**强行拉回正确位置**。

---

## 二、本项目里目前有什么约束？

**只有一种：距离约束**。

意思是：
- 粒子 i 和 j 之间的距离必须等于 `rest_length`
- 如果距离变长或变短，就把它拉回去

所以你看到的是：
- 一条“长度固定”的链条
- 没有弯曲约束，也没有自碰撞

---

## 三、约束在代码里怎么表示？

文件位置：
- [src/isaac_pbd_lab/sim/constraints.py](../src/isaac_pbd_lab/sim/constraints.py)

核心结构是一个数据类：
- `DistanceConstraint(i, j, rest_length)`

这就是“描述约束的元数据”，它**不做计算**，只负责保存信息。

你可以把它理解成：
> “这是一条规则：第 i 颗和第 j 颗之间的距离必须是 L。”

---

## 四、约束是怎么被创建的？

函数：`build_chain_constraints(n_particles, rest_length)`

逻辑非常简单：
1. 粒子从 0 到 N-1
2. 每两个相邻粒子都加一个约束

结果就是：
- 0-1 约束
- 1-2 约束
- 2-3 约束
- ...一直到 N-2 和 N-1

这就是一条链。

---

## 五、约束是怎么被“用起来”的？

约束不会自己生效，真正执行约束的是 PBD 求解器。

调用关系：
1. [src/isaac_pbd_lab/sim/system.py](../src/isaac_pbd_lab/sim/system.py) 里创建约束列表
2. 每一帧调用 `solve_constraints_pbd()`
3. `solve_constraints_pbd()` 逐条应用距离约束

也就是说：
- constraints.py 只是“定义和生成约束”
- pbd.py 才是真正“执行约束”

---

## 六、这个文件的设计逻辑（给新手看的）

你只需要记住三个原则：

### 原则 1：约束 = 数据
`DistanceConstraint` 是一个“纯数据结构”。

好处是：
- 结构简单
- 以后扩展新的约束类型很容易

### 原则 2：生成约束与执行约束分开
- constraints.py：只负责“有哪些约束”
- pbd.py：负责“怎么满足约束”

这样设计清晰，职责单一。

### 原则 3：最大残差用于监控
`max_distance_residual()` 只是统计“约束偏离得有多大”。
它**不改变位置**，只是用来打印日志。

---

## 七、新增约束怎么做？（详细步骤）

下面是一个**通用模板**，你可以照着做。

### 步骤 1：定义一个新的约束数据结构
在 [src/isaac_pbd_lab/sim/constraints.py](../src/isaac_pbd_lab/sim/constraints.py) 里添加：

例如“固定点约束”（把某个粒子固定在某个位置）：
- `FixedPointConstraint(i, target_pos)`

### 步骤 2：生成这种约束
在 constraints.py 里新增一个构建函数，比如：
- `build_fixed_constraints(indices, target_positions)`

### 步骤 3：在 system.py 里把它加入约束列表
你可以维护多个列表：
- `distance_constraints`
- `fixed_constraints`

或者把它们合并到一个总列表里。

### 步骤 4：在 pbd.py 里增加“投影规则”
对于每一种约束，都要写它的投影公式。

你需要考虑：
- 约束函数 $C(x)=0$ 怎么写
- 梯度怎么计算
- 如何修改粒子位置

### 步骤 5：给残差统计写一个对应函数
比如 `max_fixed_residual()` 或者统一处理。

---

## 八、最常见的新增约束例子

### 1) 固定点约束（Pin Constraint）
**效果**：某个粒子永远固定在一个位置。

实现思路：
- 约束函数：$C(x)=||x_i - x_{target}|| = 0$
- 梯度就是向目标方向

### 2) 弯曲约束（Bending Constraint）
**效果**：让链条不那么容易折成 V。

实现思路：
- 对三点角度进行约束
- 或者对相隔两段的距离进行约束

### 3) 碰撞约束（Collision Constraint）
**效果**：粒子不能穿过地面或彼此穿透。

本项目目前只做了一个简单地面投影（不是严格约束）。

---

## 九、推荐的代码组织方式（适合扩展）

为了以后好扩展，建议这样整理：

- constraints.py：只放“约束定义 + 构建函数 + 残差统计”
- pbd.py：写投影算法（可拆成多个函数）
- system.py：集中管理所有约束列表

如果约束变多，建议写成：
- `solve_distance_constraints()`
- `solve_fixed_constraints()`
- `solve_bending_constraints()`

---

## 十、简单的“新增约束模板”（概念级）

1. 定义数据结构
2. 生成约束列表
3. 在 system 里保存
4. 在 pbd 里写投影
5. 在日志里输出残差

只要按这个顺序来，就不会乱。

---

## 十一、你读完应该能回答的问题

- 约束在项目里是“数据”还是“算法”？
- 新增约束时，哪部分应该改、哪部分不该改？
- 为什么要把约束定义和求解分开？

如果能答出来，就说明你已经理解了。
